---
alwaysApply: true
description: Establece las normas de trabajo y procedimientos sobre `git` para un equipo de desarrollo
---
# üõ†Ô∏è Protocolo y Pol√≠ticas de Trabajo con Git para Equipos de Desarrollo

Para asegurar que trabajamos de forma ordenada y mantenemos la calidad del c√≥digo, tienes que seguir estos pasos y pol√≠ticas en tu d√≠a a d√≠a.

## 1. üå± Estrategia de Ramas (Branching Strategy)

### 1.1. Estructura de Ramas Principal

Adoptar√°s una variante del *Gitflow* con las siguientes ramas permanentes:

- main: Contiene √∫nicamente el c√≥digo estable y listo para producci√≥n. Est√° protegida contra pushes directos.
- develop: Rama de integraci√≥n donde se unen las funcionalidades completadas para preparar el siguiente release. Tambi√©n est√° protegida contra pushes directos.

### 1.2. Ramas de Desarrollo (Feature Branches)

- Nomenclatura: Ejemplos: `feature/descripcion-breve`, `fix/issue-123`, o `hotfix/urgencia-corta`.
- Caracter√≠sticas: Asegura que las ramas tengan una vida corta (< 1 d√≠a) para minimizar conflictos de fusi√≥n.
- Creaci√≥n desde develop: `git checkout -b feature/nueva-funcionalidad develop`

## 2. üíª Flujo de Trabajo Diario

### 2.1. Comenzar a Trabajar

- Sincroniza siempre primero: Antes de crear tu rama, tienes que actualizar tu develop local para tener la √∫ltima versi√≥n del c√≥digo y evitar conflictos:

    ```bash
    git checkout develop
    git pull origin develop
    ```

  Esto evita conflictos al garantizar que trabajas con la versi√≥n m√°s reciente del c√≥digo.
- Crea rama de feature: Una vez actualizado, crea tu rama `git checkout -b feature/nombre-feature`

### 2.2. Trabajar en Cambios

Mientras trabajas en los cambios:

- Verifica el estado frecuentemente: Usa `git status` para monitorear cambios realizados, archivos modificados y la rama actual.
- **Quality Gates Obligatorios**: Antes de cada commit, DEBES ejecutar la secuencia completa de calidad de c√≥digo:
  1. `uv run ruff format .` - Formatear c√≥digo
  2. `uv run ruff check . --fix` - Corregir errores de linting
  3. `uv run mypy .` - Verificar tipado est√°tico
  4. `uv run pytest` - Ejecutar pruebas
- Realiza commits at√≥micos: Tienes que hacer commits con frecuencia. Cada commit debe representar una unidad l√≥gica de cambio.
- Mensajes claros: Usa el formato convencional:

    ```text
    <tipo>(<alcance>): <asunto>

    <cuerpo>

    <pie>
    ```

    Ejemplo:

    ```text
    feat(payment): integrate with Stripe API

    - Add Stripe SDK dependency
    - Create payment intent service
    - Handle webhook for payment confirmation

    Refs: #123
    ```

### 2.3. Finalizar una Funcionalidad

Cuando termines tu tarea, tienes que seguir estos pasos:

1. **Pre-commit Quality Check**: Ejecuta la secuencia completa de calidad de c√≥digo una √∫ltima vez:

   ```bash
   uv run ruff format .
   uv run ruff check . --fix
   uv run mypy .
   uv run pytest
   ```

2. **Commit Final**: Realiza el commit final con todos los cambios.
3. Sube tu rama al repositorio remoto: `git push origin feature/nombre-feature`.
4. Crea un Pull Request (PR) o Merge Request (MR) hacia develop.
5. Espera la revisi√≥n de c√≥digo por al menos un compa√±ero, que en este caso ser√© yo.
6. Realiza los ajustes solicitados en la revisi√≥n.
7. El revisor aprueba y fusiona el PR/MR. La rama de feature se elimina tras la fusi√≥n.

## 3. ‚úÖ Tus Responsabilidades sobre la Calidad del C√≥digo

### 3.1. En las Revisiones de C√≥digo (Code Review)

- Requisito obligatorio: Todo tu c√≥digo debe ser revisado antes de poder integrarse en develop.
- Tu responsabilidad como autor: Debes aceptar la revisi√≥n como una herramienta para mantener la calidad y compartir conocimiento.
- Tu responsabilidad como revisor: Eres tan responsable como el autor de la calidad del c√≥digo que apruebas.

### 3.2. Con Integraci√≥n Continua (CI)

- Cada PR que abras debe disparar un pipeline de CI que ejecute, como m√≠nimo, linting, an√°lisis est√°tico, pruebas unitarias y verificaci√≥n de vulnerabilidades.
- Criterio para fusionar: Tienes que asegurarte de que el pipeline pase con √©xito. Si no, la fusi√≥n no est√° permitida.
- Prioridad m√°xima: Si las pruebas fallan o el build se rompe en develop, tienes que priorizar su soluci√≥n junto con el equipo.

## 4. üö® Prevenci√≥n y Manejo de Conflictos

- Cambios peque√±os y frecuentes: Realizar cambios incrementales reduce dr√°sticamente el riesgo de conflictos de fusi√≥n.
- Actualizar frecuentemente: Si trabajas en una rama larga, fusiona (merge) los cambios de develop a tu rama regularmente para mantenerla actualizada.
- Antes de fusionar: Siempre ejecuta git pull origin develop en tu rama de feature para resolver conflictos localmente antes de crear el PR/MR.

## 5. üìã C√≥mo Debes Crear y Gestionar tus Pull Requests

Cada PR/MR debe cumplir con lo siguiente antes de su fusi√≥n:

- **Quality Gates Verificados**: C√≥digo formateado con `ruff format`, sin errores de linting (`ruff check`), tipado correcto (`mypy`), y todas las pruebas pasando (`pytest`).
- C√≥digo compila sin errores.
- Tests automatizados pasan correctamente.
- Cobertura de c√≥digo se mantiene o mejora.
- Cumple con gu√≠as de estilo del proyecto (linter).
- Documentaci√≥n actualizada (si aplica).
- Revisado y aprobado por al menos un compa√±ero.
- Conflictos de fusi√≥n resueltos (si existen).
- La rama est√° actualizada con develop.

## 6. üîß Pre-commit Workflow Obligatorio

### 6.1. Secuencia de Quality Gates

**ANTES de cada commit**, debes ejecutar esta secuencia completa:

```bash
# 1. Formatear c√≥digo
uv run ruff format .

# 2. Corregir errores de linting autom√°ticamente
uv run ruff check . --fix

# 3. Verificar tipado est√°tico
uv run mypy .

# 4. Ejecutar pruebas
uv run pytest

# 5. Solo si todo pasa, hacer commit
git add .
git commit -m "feat(scope): descripci√≥n del cambio"
```

### 6.2. Manejo de Errores

- **Si `ruff check` falla**: Corrige los errores manualmente y vuelve a ejecutar.
- **Si `mypy` falla**: A√±ade tipos faltantes o corrige errores de tipado.
- **Si `pytest` falla**: Corrige las pruebas o el c√≥digo hasta que pasen.
- **NUNCA hagas commit con errores**: Es preferible hacer commits peque√±os y frecuentes que un commit grande con errores.

### 6.3. Automatizaci√≥n Recomendada

Para evitar olvidar estos pasos, configura un hook de pre-commit:

```bash
# Instalar pre-commit
uv add --dev pre-commit

# Crear .pre-commit-config.yaml
cat > .pre-commit-config.yaml << EOF
repos:
  - repo: local
    hooks:
      - id: ruff-format
        name: ruff-format
        entry: uv run ruff format
        language: system
        types: [python]
      - id: ruff-check
        name: ruff-check
        entry: uv run ruff check --fix
        language: system
        types: [python]
      - id: mypy
        name: mypy
        entry: uv run mypy
        language: system
        types: [python]
      - id: pytest
        name: pytest
        entry: uv run pytest
        language: system
        types: [python]
EOF

# Instalar el hook
uv run pre-commit install
```

## 7. üóÇÔ∏è Manejo del Repositorio

- No incluir archivos binarios o generados: Evitar commits de archivos compilados, dependencias (node_modules, .jar) o archivos espec√≠ficos del IDE. Utilizar .gitignore robusto.
- Commits limpios: Antes de hacer commit, revisar qu√© se est√° incluyendo con `git diff --staged`.
- Seguridad: Agregar un archivo SECURITY.md en la ra√≠z del repositorio para proporcionar instrucciones sobre c√≥mo reportar vulnerabilidades de seguridad.

## 8. üîÄ Pol√≠tica de Pull Requests

### 8.1. Principios Fundamentales

- Responsabilidad √önica: Tu PR debe tener un √∫nico prop√≥sito espec√≠fico. No incluyas correcciones no relacionadas en un PR de una nueva caracter√≠stica.
- Tama√±o Reducido: Tienes que mantener tus PRs peque√±os (idealmente menos de 200-400 l√≠neas de c√≥digo). Son m√°s f√°ciles y r√°pidos de revisar.
- Contexto Completo: Tienes que proporcionar descripciones detalladas que expliquen el prop√≥sito del PR y enlazar a los issues relacionados.
- T√≠tulos Descriptivos: Usa t√≠tulos claros que describan lo que hace el PR, no solo la clave del issue.

### 8.2. Creaci√≥n de Pull Requests

#### 8.2.1. Plantilla Est√°ndar para Pull Requests

```markdown

## Descripci√≥n

[Descripci√≥n clara del prop√≥sito de estos cambios]

## Cambios Realizados

- [Lista de cambios principales]
- [Agrupar por conceptos o problemas resueltos]

## Tipo de Cambio

- [ ] Correcci√≥n de bug
- [ ] Nueva caracter√≠stica
- [ ] Cambio breaking
- [ ] Refactorizaci√≥n
- [ ] Documentaci√≥n

## Comprobaciones

- [ ] He auto-revisado mi PR
- [ ] **Quality Gates ejecutados**: `ruff format`, `ruff check --fix`, `mypy`, `pytest`
- [ ] El c√≥digo compila/pasa tests
- [ ] He a√±adido tests si corresponde
- [ ] He actualizado la documentaci√≥n

## Capturas (si aplica)

[A√±adir capturas de pantalla para cambios de frontend]

## Issues Relacionados

Closes #[n√∫mero], Fixes #[n√∫mero]
```

#### 8.2.2. Pr√°cticas Espec√≠ficas

- Auto-revisi√≥n: Tienes que revisar, compilar y probar tu propio PR antes de enviarlo a revisi√≥n.
- PRs en Borrador: Utiliza la funci√≥n de PRs en borrador (Draft) para obtener feedback temprano si la funcionalidad no est√° completa.
- Comentarios Gu√≠a: Si es necesario, a√±ade comentarios en l√≠neas espec√≠ficas de tu PR para dirigir la atenci√≥n del revisor.
- Actualizaciones post-aprobaci√≥n: Si realizas un cambio importante despu√©s de que tu PR haya sido aprobado, tienes que notificar a los revisores para que lo miren de nuevo.

### 8.3. Proceso de Revisi√≥n

#### 8.3.1. Para el Autor

- S√© Proactivo: Considera organizar una reuni√≥n breve para PRs largos y explica los cambios.
- Actitud Constructiva: Mant√©n un tono profesional en los comentarios. Los comentarios se centran en el c√≥digo, no en las personas.
- Retroalimentaci√≥n: Si cambias algo importante despu√©s de la aprobaci√≥n, notifica a los revisores anteriores para que revisen nuevamente.

#### 8.3.2. Para el Revisor

- Revisi√≥n R√°pida: Responde a las solicitudes de review en un plazo m√°ximo de un d√≠a h√°bil.
- Feedback Espec√≠fico: Evita comentarios vagos. Proporciona alternativas concretas cuando no est√©s de acuerdo.
- Revisi√≥n Multidisciplinaria: Incluye expertos en diferentes √°reas seg√∫n el tipo de cambios (UX para frontend, seguridad para cambios cr√≠ticos, etc.).

### 8.4. Automatizaci√≥n y QA

- Integraci√≥n Continua: Configura pipelines autom√°ticos que ejecuten tests y an√°lisis est√°tico en cada PR.
- An√°lisis Est√°tico: Usa herramientas de linting para mantener la coherencia del estilo de c√≥digo.
- Revisi√≥n de Seguridad: Incluye verificaciones de seguridad automatizadas para detectar dependencias vulnerables.

## 9. üìÑ Generaci√≥n y Gesti√≥n de Changelogs

### 9.1. ¬øQu√© es un Changelog?

Un changelog es un archivo que contiene una lista cronol√≥gica de todos los cambios notables realizados en un proyecto, organizado normalmente por versi√≥n con la fecha, seguido de una lista de caracter√≠sticas a√±adidas, mejoradas y eliminadas.

### 9.2. Enfoques para Generar Changelogs

#### 9.2.1. Enfoque Manual (Recomendado)

Mant√©n un archivo `CHANGELOG.md` siguiendo el formato de Keep a Changelog:

```markdown

# Changelog

Todos los cambios notables en este proyecto ser√°n documentados en este archivo.

El formato est√° basado en [Keep a Changelog](https://keepachangelog.com/es-ES/1.1.0/),
y este proyecto adhiere a [Semantic Versioning](https://semver.org/spec/v2.0.0.html).

## [No Liberado]

### A√±adido

-

### Cambiado

-

### Corregido

-

### Eliminado

-

## [1.1.1] - 2023-03-05

### A√±adido

- Traducci√≥n al √°rabe (#444)
- v1.1 traducci√≥n al franc√©s
```

#### 9.2.2. Enfoque Automatizado

- M√©todo Simple (para proyectos peque√±os):

    ```bash

    # Generar changelog b√°sico desde commits

    git log --pretty="- %s" > CHANGELOG.md

    # Con formato mejorado

    git log --pretty="- %s (%an, %ad)" --date=short > CHANGELOG.md
    ```

- Herramientas Especializadas:

| Herramienta        | Lenguaje | Caracter√≠sticas                                    |
| ------------------ | -------- | -------------------------------------------------- |
| git-cliff          | Rust     | Altamente personalizable, commits convencionales   |
| generate-changelog | Node.js  | Formato espec√≠fico, requiere estructura de commits |
| git-changelog      | Python   | Plantillas Jinja2, m√∫ltiples convenciones          |

### 9.3. Convenci√≥n de Commits para Changelogs Automatizados

Para aprovechar las herramientas automatizadas, implementa una convenci√≥n de commits:

```text
<tipo>(<√°mbito>): <descripci√≥n> [flags]

Ejemplos:
feat(auth): add OAuth2 integration
fix(api): resolve memory leak in request handler
docs(readme): update installation instructions
breaking(db): remove deprecated methods
```

Los tipos com√∫nmente aceptados incluyen: feat, fix, docs, style, refactor, test, chore.

### 9.4. Flujo de Trabajo Integrado

- Pre-commit: Los desarrolladores siguen la convenci√≥n establecida
- Pre-release: Ejecutar herramienta de generaci√≥n de changelog
- Revisi√≥n: Revisar y ajustar el changelog generado autom√°ticamente
- Commit: Incluir changelog actualizado en el tag de release
